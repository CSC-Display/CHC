<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sports Club Data Scraper</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #0056b3;
        }
        
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #1e7e34;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #545b62;
        }
        
        #status {
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            font-weight: bold;
        }
        
        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .data-preview {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            max-height: 400px;
            overflow: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #f8f9fa;
            font-weight: bold;
            position: sticky;
            top: 0;
        }
        
        tr:hover {
            background-color: #f5f5f5;
        }
        
        .hidden {
            display: none;
        }
        
        .gms-wrapper {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sports Club Fixtures & Results to CSV</h1>
        
        <div class="controls">
            <button id="loadData" class="btn-primary">Load Sports Data</button>
            <button id="exportCSV" class="btn-success" disabled>Export to CSV</button>
            <button id="clearData" class="btn-secondary">Clear Data</button>
        </div>
        
        <div id="status" class="hidden"></div>
        
        <div id="dataPreview" class="data-preview hidden">
            <table id="dataTable">
                <thead id="tableHeader"></thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
        
        <!-- Original GMS wrapper -->
        <div class="gms-wrapper gms-ajax" 
             data-method="api" 
             data-show="results" 
             data-club_id="e9ba26d3-7e18-4772-abb0-584e887c9d38" 
             data-whatson="7" 
             data-sort_by="fixtureTime" 
             data-options="showGender:yes,showList:yes"
             data-css="no">
            <div class="loading">Loading sports data...</div>
        </div>
    </div>

    <script src="https://gmsfeed.co.uk/js/api.js"></script>
    <script>
        let sportsData = [];
        let dataLoaded = false;

        // Status display function
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status-${type}`;
            statusEl.classList.remove('hidden');
        }

        // Extract sports data directly (since it's already loaded)
        function extractSportsData() {
            return new Promise((resolve, reject) => {
                const gmsWrapper = document.querySelector('.gms-wrapper');
                
                console.log('Extracting data directly from loaded content...');
                console.log('GMS Wrapper content:', gmsWrapper.innerHTML);
                console.log('GMS Wrapper text:', gmsWrapper.textContent);
                
                // Check if we have actual data (not just loading message)
                const hasLoadingMessage = gmsWrapper.textContent.includes('Loading sports data...');
                const hasContent = gmsWrapper.textContent.trim().length > 30;
                
                // Count elements
                const tables = gmsWrapper.querySelectorAll('table');
                const rows = gmsWrapper.querySelectorAll('tr');
                const divs = gmsWrapper.querySelectorAll('div');
                const spans = gmsWrapper.querySelectorAll('span');
                const links = gmsWrapper.querySelectorAll('a');
                const allElements = gmsWrapper.querySelectorAll('*');
                
                console.log('Content analysis:', {
                    hasLoadingMessage,
                    hasContent,
                    textLength: gmsWrapper.textContent.trim().length,
                    totalElements: allElements.length,
                    tables: tables.length,
                    rows: rows.length,
                    divs: divs.length,
                    spans: spans.length,
                    links: links.length
                });
                
                // If we only have the loading message, the API hasn't loaded yet
                if (hasLoadingMessage && !hasContent) {
                    console.log('Still showing loading message, waiting for API...');
                    waitForAPIToLoad().then(resolve).catch(reject);
                    return;
                }
                
                // Try to extract data from what we have
                try {
                    const extractedData = parseGMSData(gmsWrapper);
                    console.log('Directly extracted data:', extractedData);
                    
                    if (extractedData.length > 0) {
                        resolve(extractedData);
                    } else {
                        console.log('No data extracted, waiting for API...');
                        waitForAPIToLoad().then(resolve).catch(reject);
                    }
                } catch (error) {
                    console.log('Error extracting data:', error);
                    reject(error);
                }
            });
        }

        // Wait for API to load (fallback function)
        function waitForAPIToLoad() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 30; // Wait up to 15 seconds
                
                function checkForChanges() {
                    attempts++;
                    const gmsWrapper = document.querySelector('.gms-wrapper');
                    
                    console.log(`Waiting attempt ${attempts}...`);
                    
                    // Check if content has changed from loading message
                    const currentText = gmsWrapper.textContent.trim();
                    const stillLoading = currentText.includes('Loading sports data...');
                    const hasNewContent = currentText.length > 50 && !stillLoading;
                    
                    if (hasNewContent) {
                        console.log('Content has loaded!');
                        try {
                            const data = parseGMSData(gmsWrapper);
                            if (data.length > 0) {
                                resolve(data);
                                return;
                            }
                        } catch (error) {
                            console.log('Error parsing new content:', error);
                        }
                    }
                    
                    if (attempts >= maxAttempts) {
                        // Try one final extraction
                        try {
                            const finalData = parseGMSData(gmsWrapper);
                            if (finalData.length > 0) {
                                resolve(finalData);
                                return;
                            }
                        } catch (error) {
                            console.log('Final extraction failed:', error);
                        }
                        
                        reject(new Error(`API did not load data. Current content: ${currentText.substring(0, 200)}`));
                        return;
                    }
                    
                    setTimeout(checkForChanges, 500);
                }
                
                checkForChanges();
            });
        }

        // Parse the loaded GMS data
        function parseGMSData(container) {
            const data = [];
            console.log('Parsing GMS data from container:', container);
            
            // Get all the HTML content for analysis
            const allHTML = container.innerHTML;
            const allText = container.textContent.trim();
            
            console.log('Container HTML length:', allHTML.length);
            console.log('Container text:', allText);
            
            // Try different approaches to extract data
            
            // Approach 1: Look for table data (Enhanced for sports fixtures)
            const tables = container.querySelectorAll('table');
            console.log('Found tables:', tables.length);
            
            if (tables.length > 0) {
                tables.forEach((table, tableIndex) => {
                    console.log(`Processing table ${tableIndex}`);
                    const rows = table.querySelectorAll('tr');
                    let headers = [];
                    
                    // Get headers - try different approaches
                    if (rows.length > 0) {
                        const headerRow = rows[0];
                        const headerCells = headerRow.querySelectorAll('th, td');
                        
                        // Extract headers
                        headerCells.forEach(cell => {
                            const headerText = cell.textContent.trim();
                            if (headerText) {
                                headers.push(headerText);
                            }
                        });
                        
                        console.log('Table headers found:', headers);
                        
                        // If no proper headers found, create default ones based on sports data
                        if (headers.length === 0 || headers.every(h => h.length < 2)) {
                            headers = ['Date', 'Home Team', 'Score', 'Away Team', 'Location'];
                            console.log('Using default headers:', headers);
                        }
                    }
                    
                    // Get data rows (start from row 0 if no headers, row 1 if headers exist)
                    const startRow = headers.length > 0 && rows[0]?.querySelector('th') ? 1 : 0;
                    
                    for (let i = startRow; i < rows.length; i++) {
                        const row = rows[i];
                        const rowData = {};
                        const cells = row.querySelectorAll('td, th');
                        
                        console.log(`Row ${i} has ${cells.length} cells`);
                        
                        cells.forEach((cell, index) => {
                            const cellText = cell.textContent.trim();
                            const header = headers[index] || `Column_${index + 1}`;
                            
                            // Special handling for sports data
                            if (cellText) {
                                // Check if this cell contains a score pattern (e.g., "2:1", "02:00", "3-1")
                                if (/^\d+[\s]*[:\-]\s*\d+$/.test(cellText)) {
                                    rowData[header] = cellText;
                                }
                                // Check if this looks like a date
                                else if (/\d{1,2}[-\/\s]\w{3}[-\/\s]\d{2,4}|\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}/.test(cellText)) {
                                    rowData[header] = cellText;
                                }
                                // Regular content
                                else {
                                    rowData[header] = cellText;
                                }
                            }
                        });
                        
                        // Only add row if it has meaningful data
                        const meaningfulData = Object.values(rowData).some(val => val && val.length > 0);
                        if (meaningfulData) {
                            console.log('Adding row data:', rowData);
                            data.push(rowData);
                        }
                    }
                });
                
                // If we found table data, return it
                if (data.length > 0) {
                    console.log('Successfully parsed table data:', data);
                    return data;
                }
            }
            
            // Approach 2: Parse raw text data for sports fixtures (FIXED)
            if (data.length === 0 && allText && allText.length > 50) {
                console.log('Parsing raw text data for sports fixtures');
                
                // Split text into lines and clean them
                const lines = allText.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
                
                console.log('Text lines found:', lines);
                
                // Look for fixture patterns - each fixture should be a group of related lines
                const fixtures = [];
                let i = 0;
                
                while (i < lines.length) {
                    const line = lines[i];
                    
                    // Skip headers
                    if (line.toLowerCase().includes('date') || 
                        line.toLowerCase().includes('home') || 
                        line.toLowerCase().includes('away') ||
                        line.toLowerCase().includes('score') ||
                        line.toLowerCase().includes('location') ||
                        line.includes('[Club match') ||
                        line.length < 5) {
                        i++;
                        continue;
                    }
                    
                    // Check if this line looks like a date (start of new fixture)
                    const dateMatch = line.match(/(\d{1,2}\s+\w{3}\s+\d{4})/);
                    if (dateMatch) {
                        const fixture = {
                            Date: dateMatch[1],
                            OriginalText: line
                        };
                        
                        // Extract the rest of the fixture data from this line
                        // Pattern: "20 Sep 2025Chelmsford 5 (F)2 : 1Southend & Benfleet 3Chelmsford HC - Chelmer Park - Pitch 1"
                        let remainingText = line.replace(dateMatch[1], '').trim();
                        
                        // Try to extract score pattern first (easier to identify)
                        const scoreMatch = remainingText.match(/(\d+\s*:\s*\d+)/);
                        if (scoreMatch) {
                            fixture.Score = scoreMatch[1];
                            
                            // Split by score to get home team (before) and away team + location (after)
                            const parts = remainingText.split(scoreMatch[1]);
                            if (parts.length >= 2) {
                                fixture.HomeTeam = parts[0].trim();
                                
                                // For away team and location, we need to be smarter
                                const afterScore = parts[1].trim();
                                
                                // Look for team name patterns:
                                // - Chelmsford teams: end with number + optional (M)/(F) like "Chelmsford 5 (F)" or "Chelmsford 3"
                                // - Other teams: may end with number like "Southend & Benfleet 3" or just name
                                
                                let awayTeam = '';
                                let location = '';
                                
                                // Pattern 1: Look for Chelmsford teams (Chelmsford + number + optional (M/F))
                                const chelmsfordMatch = afterScore.match(/^(.*?Chelmsford\s+\d+(?:\s*\([MF]\))?)(.*)/i);
                                if (chelmsfordMatch) {
                                    awayTeam = chelmsfordMatch[1].trim();
                                    location = chelmsfordMatch[2].trim();
                                }
                                // Pattern 2: Look for other teams ending with numbers
                                else {
                                    // Try to find where the team name ends by looking for location keywords
                                    const locationKeywords = ['HC', 'School', 'Club', 'Park', 'Pitch', 'Centre', 'Ground'];
                                    let bestSplit = -1;
                                    
                                    for (const keyword of locationKeywords) {
                                        const keywordIndex = afterScore.indexOf(keyword);
                                        if (keywordIndex > 0) {
                                            // Find the start of the word containing this keyword
                                            let wordStart = keywordIndex;
                                            while (wordStart > 0 && afterScore[wordStart - 1] !== ' ') {
                                                wordStart--;
                                            }
                                            
                                            // Check if this makes sense as a team/location split
                                            const potentialTeam = afterScore.substring(0, wordStart).trim();
                                            if (potentialTeam.length > 2) {
                                                bestSplit = wordStart;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    if (bestSplit > 0) {
                                        awayTeam = afterScore.substring(0, bestSplit).trim();
                                        location = afterScore.substring(bestSplit).trim();
                                    }
                                    // Fallback: Look for team names that end with numbers
                                    else {
                                        const teamNumberMatch = afterScore.match(/^(.*?\w+\s+\d+)(.*)$/);
                                        if (teamNumberMatch) {
                                            awayTeam = teamNumberMatch[1].trim();
                                            location = teamNumberMatch[2].trim();
                                        }
                                        // Last resort: split roughly in the middle or use the whole thing as team
                                        else {
                                            const words = afterScore.split(' ');
                                            if (words.length > 3) {
                                                // Assume first few words are team name
                                                awayTeam = words.slice(0, Math.ceil(words.length / 2)).join(' ');
                                                location = words.slice(Math.ceil(words.length / 2)).join(' ');
                                            } else {
                                                awayTeam = afterScore;
                                                location = '';
                                            }
                                        }
                                    }
                                }
                                
                                fixture.AwayTeam = awayTeam;
                                fixture.Location = location;
                            }
                        } else {
                            // No score found, treat as fixture (not result)
                            fixture.Score = '';
                            fixture.HomeTeam = remainingText;
                            fixture.AwayTeam = '';
                            fixture.Location = '';
                        }
                        
                        fixtures.push(fixture);
                    }
                    
                    i++;
                }
                
                console.log('Parsed fixtures:', fixtures);
                
                if (fixtures.length > 0) {
                    return fixtures;
                }
                
                // Alternative approach: try to split the long concatenated string
                if (fixtures.length === 0) {
                    console.log('Trying alternative parsing for concatenated data');
                    
                    // Look for date patterns in the text to split fixtures
                    const datePattern = /(\d{1,2}\s+\w{3}\s+\d{4})/g;
                    const dateMatches = [];
                    let match;
                    
                    while ((match = datePattern.exec(allText)) !== null) {
                        dateMatches.push({
                            date: match[1],
                            index: match.index
                        });
                    }
                    
                    console.log('Date matches found:', dateMatches);
                    
                    // Split text at each date
                    for (let j = 0; j < dateMatches.length; j++) {
                        const currentMatch = dateMatches[j];
                        const nextMatch = dateMatches[j + 1];
                        
                        const startIndex = currentMatch.index;
                        const endIndex = nextMatch ? nextMatch.index : allText.length;
                        const fixtureText = allText.substring(startIndex, endIndex).trim();
                        
                        // Parse this individual fixture
                        const fixture = {
                            Date: currentMatch.date,
                            FixtureText: fixtureText
                        };
                        
                        // Extract score
                        const scoreMatch = fixtureText.match(/(\d+\s*:\s*\d+)/);
                        if (scoreMatch) {
                            fixture.Score = scoreMatch[1];
                            
                            // Split around the score
                            const beforeScore = fixtureText.substring(0, fixtureText.indexOf(scoreMatch[1]));
                            const afterScore = fixtureText.substring(fixtureText.indexOf(scoreMatch[1]) + scoreMatch[1].length);
                            
                            // Home team is after the date
                            fixture.HomeTeam = beforeScore.replace(currentMatch.date, '').trim();
                            
                            // Away team and location parsing with improved logic
                            const afterScoreTrimmed = afterScore.trim();
                            
                            let awayTeam = '';
                            let location = '';
                            
                            // Special case: Check if this is a Chelmsford home game (location will be ChelmsfordHC)
                            const chelmsfordHomeMatch = afterScoreTrimmed.match(/^(.+?)(ChelmsfordHC\s*-\s*Chelmer\s*Park\s*-\s*Pitch\s*\d+)$/i);
                            if (chelmsfordHomeMatch) {
                                awayTeam = chelmsfordHomeMatch[1].trim();
                                location = chelmsfordHomeMatch[2].trim();
                            }
                            // Pattern 1: Check for Chelmsford away teams (Chelmsford + number + optional (M/F))
                            else {
                                const chelmsfordMatch = afterScoreTrimmed.match(/^(.*?Chelmsford\s+\d+(?:\s*\([MF]\))?)(.*)/i);
                                if (chelmsfordMatch) {
                                    awayTeam = chelmsfordMatch[1].trim();
                                    location = chelmsfordMatch[2].trim();
                                }
                                // Pattern 2: Look for other teams that end with numbers
                                else {
                                    // Try to identify where team name ends by looking for location keywords
                                    const locationKeywords = ['HC', 'School', 'Club', 'Park', 'Pitch', 'Centre', 'Ground'];
                                    let bestSplit = -1;
                                    
                                    for (const keyword of locationKeywords) {
                                        const keywordIndex = afterScoreTrimmed.indexOf(keyword);
                                        if (keywordIndex > 0) {
                                            // Find the start of the word containing this keyword
                                            let wordStart = keywordIndex;
                                            while (wordStart > 0 && afterScoreTrimmed[wordStart - 1] !== ' ') {
                                                wordStart--;
                                            }
                                            
                                            // Check if this makes sense as a team/location split
                                            const potentialTeam = afterScoreTrimmed.substring(0, wordStart).trim();
                                            if (potentialTeam.length > 2) {
                                                bestSplit = wordStart;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    if (bestSplit > 0) {
                                        awayTeam = afterScoreTrimmed.substring(0, bestSplit).trim();
                                        location = afterScoreTrimmed.substring(bestSplit).trim();
                                    }
                                    // Pattern 3: Look for team names ending with numbers (like "Southend & Benfleet 3")
                                    else {
                                        const teamNumberMatch = afterScoreTrimmed.match(/^(.*?\b\w+\s+\d+)(.*)$/);
                                        if (teamNumberMatch) {
                                            awayTeam = teamNumberMatch[1].trim();
                                            location = teamNumberMatch[2].trim();
                                        }
                                        // Pattern 4: Look for team names ending with "Development", "Evergreens", etc.
                                        else {
                                            const teamSuffixMatch = afterScoreTrimmed.match(/^(.*?\b(?:Development|Evergreens|Centurions)\b)(.*)$/i);
                                            if (teamSuffixMatch) {
                                                awayTeam = teamSuffixMatch[1].trim();
                                                location = teamSuffixMatch[2].trim();
                                            }
                                            // Last resort: assume first reasonable chunk is team name
                                            else {
                                                const words = afterScoreTrimmed.split(' ');
                                                if (words.length > 4) {
                                                    // Take first 3-4 words as team name
                                                    awayTeam = words.slice(0, 3).join(' ');
                                                    location = words.slice(3).join(' ');
                                                } else {
                                                    awayTeam = afterScoreTrimmed;
                                                    location = '';
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            fixture.AwayTeam = awayTeam;
                            fixture.Location = location;
                        }
                        
                        fixtures.push(fixture);
                    }
                    
                    console.log('Alternative parsed fixtures:', fixtures);
                    return fixtures;
                }
            }
            
            // Approach 3: Look for structured content with specific selectors
            if (data.length === 0) {
                const listItems = container.querySelectorAll('li, .fixture, .result, .match, .game, .event');
                console.log('Found structured items:', listItems.length);
                
                listItems.forEach((item, index) => {
                    const text = item.textContent.trim();
                    if (text && text.length > 10) {
                        // Try to parse individual fixture from this item
                        const fixtureData = { ItemIndex: index + 1 };
                        
                        // Look for date patterns
                        const dateMatch = text.match(/\d{1,2}[-\/\s]\w{3}[-\/\s]\d{2,4}|\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}/);
                        if (dateMatch) {
                            fixtureData.Date = dateMatch[0];
                        }
                        
                        // Look for score patterns
                        const scoreMatch = text.match(/\d+[\s]*[:\-]\s*\d+/);
                        if (scoreMatch) {
                            fixtureData.Score = scoreMatch[0];
                        }
                        
                        // Store full content
                        fixtureData.Content = text;
                        fixtureData.TagName = item.tagName;
                        fixtureData.ClassName = item.className;
                        
                        data.push(fixtureData);
                    }
                });
            }
            
            // Approach 4: Look for any divs with meaningful content
            if (data.length === 0) {
                const meaningfulDivs = container.querySelectorAll('div');
                console.log('Found divs:', meaningfulDivs.length);
                
                meaningfulDivs.forEach((div, index) => {
                    const text = div.textContent.trim();
                    // Skip empty divs and the loading div
                    if (text && text.length > 10 && !text.includes('Loading sports data')) {
                        const hasNumbers = /\d/.test(text);
                        const hasLetters = /[a-zA-Z]/.test(text);
                        
                        if (hasNumbers && hasLetters) {
                            data.push({
                                DivIndex: index + 1,
                                Content: text,
                                ClassName: div.className || 'no-class'
                            });
                        }
                    }
                });
            }
            
            // Approach 5: Final fallback - create structured data from any content
            if (data.length === 0 && allText && allText.length > 50) {
                console.log('Final fallback: creating structured data from all content');
                
                // Just capture everything as a single record for manual review
                data.push({
                    Type: 'Raw Content',
                    AllText: allText,
                    TextLength: allText.length,
                    Note: 'Manual parsing may be required'
                });
            }
            
            console.log('Final parsed data:', data);
            return data;
        }

        // Display data in preview table (with specific column order)
        function displayData(data) {
            if (data.length === 0) {
                showStatus('No data found to display', 'error');
                return;
            }
            
            const preview = document.getElementById('dataPreview');
            const header = document.getElementById('tableHeader');
            const body = document.getElementById('tableBody');
            
            // Clear existing content
            header.innerHTML = '';
            body.innerHTML = '';
            
            // Define the desired column order
            const desiredOrder = ['Date', 'HomeTeam', 'Score', 'AwayTeam', 'Location'];
            
            // Get all available keys from the data, excluding unwanted ones
            const allKeys = new Set();
            data.forEach(row => {
                Object.keys(row).forEach(key => {
                    if (!['FixtureText', 'OriginalText', 'FixtureNumber'].includes(key)) {
                        allKeys.add(key);
                    }
                });
            });
            
            // Create ordered keys list - desired order first, then any extras
            const keys = [];
            desiredOrder.forEach(key => {
                if (allKeys.has(key)) {
                    keys.push(key);
                    allKeys.delete(key);
                }
            });
            // Add any remaining keys that weren't in our desired order
            keys.push(...Array.from(allKeys));
            
            // Create header
            const headerRow = document.createElement('tr');
            keys.forEach(key => {
                const th = document.createElement('th');
                th.textContent = key;
                headerRow.appendChild(th);
            });
            header.appendChild(headerRow);
            
            // Create data rows
            data.forEach(row => {
                const tr = document.createElement('tr');
                keys.forEach(key => {
                    const td = document.createElement('td');
                    td.textContent = row[key] || '';
                    tr.appendChild(td);
                });
                body.appendChild(tr);
            });
            
            preview.classList.remove('hidden');
            showStatus(`Successfully loaded ${data.length} records`, 'success');
        }

        // Convert data to CSV (with specific column order)
        function convertToCSV(data) {
            if (data.length === 0) return '';
            
            // Define the desired column order
            const desiredOrder = ['Date', 'HomeTeam', 'Score', 'AwayTeam', 'Location'];
            
            // Get all available keys from the data, excluding unwanted ones
            const allKeys = new Set();
            data.forEach(row => {
                Object.keys(row).forEach(key => {
                    if (!['FixtureText', 'OriginalText', 'FixtureNumber'].includes(key)) {
                        allKeys.add(key);
                    }
                });
            });
            
            // Create ordered keys list - desired order first, then any extras
            const keys = [];
            desiredOrder.forEach(key => {
                if (allKeys.has(key)) {
                    keys.push(key);
                    allKeys.delete(key);
                }
            });
            // Add any remaining keys that weren't in our desired order
            keys.push(...Array.from(allKeys));
            
            // Create CSV header
            let csv = keys.map(key => `"${key}"`).join(',') + '\n';
            
            // Add data rows
            data.forEach(row => {
                const values = keys.map(key => {
                    const value = row[key] || '';
                    // Escape quotes and wrap in quotes
                    return `"${String(value).replace(/"/g, '""')}"`;
                });
                csv += values.join(',') + '\n';
            });
            
            return csv;
        }

        // Download CSV file
        function downloadCSV(csvContent, filename = 'sports_data.csv') {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // Event listeners
        document.getElementById('loadData').addEventListener('click', async () => {
            showStatus('Extracting sports data...', 'info');
            document.getElementById('exportCSV').disabled = true;
            
            // First, let's see what's in the GMS wrapper right now
            const gmsWrapper = document.querySelector('.gms-wrapper');
            console.log('=== LOAD DATA CLICKED ===');
            console.log('Current GMS wrapper content:', gmsWrapper.innerHTML.substring(0, 500));
            console.log('Current text content:', gmsWrapper.textContent.substring(0, 200));
            
            try {
                sportsData = await extractSportsData();
                displayData(sportsData);
                document.getElementById('exportCSV').disabled = false;
                dataLoaded = true;
            } catch (error) {
                showStatus(`Error loading data: ${error.message}`, 'error');
                console.error('Error:', error);
                
                // Let's try to extract whatever we can find anyway
                try {
                    console.log('Attempting fallback extraction...');
                    const fallbackData = parseGMSData(gmsWrapper);
                    console.log('Fallback data result:', fallbackData);
                    
                    if (fallbackData.length > 0) {
                        showStatus('Extracted data using fallback method - check preview', 'success');
                        sportsData = fallbackData;
                        displayData(fallbackData);
                        document.getElementById('exportCSV').disabled = false;
                        dataLoaded = true;
                    } else {
                        showStatus('No data could be extracted. Try the Debug button to inspect content.', 'error');
                    }
                } catch (fallbackError) {
                    console.error('Fallback extraction also failed:', fallbackError);
                    showStatus('All extraction methods failed. Use Debug button to inspect.', 'error');
                }
            }
        });

        document.getElementById('exportCSV').addEventListener('click', () => {
            if (sportsData.length === 0) {
                showStatus('No data to export', 'error');
                return;
            }
            
            const csv = convertToCSV(sportsData);
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
            downloadCSV(csv, `sports_club_data_${timestamp}.csv`);
            showStatus('CSV file downloaded successfully', 'success');
        });

        document.getElementById('clearData').addEventListener('click', () => {
            sportsData = [];
            document.getElementById('dataPreview').classList.add('hidden');
            document.getElementById('status').classList.add('hidden');
            document.getElementById('exportCSV').disabled = true;
            dataLoaded = false;
            
            // Reload the page to reset everything
            showStatus('Clearing data and reloading...', 'info');
            setTimeout(() => {
                location.reload();
            }, 1000);
        });

        // Enhanced debug button
        const debugButton = document.createElement('button');
        debugButton.textContent = 'Debug: Extract Current Content';
        debugButton.className = 'btn-secondary';
        debugButton.onclick = () => {
            const gmsWrapper = document.querySelector('.gms-wrapper');
            console.log('=== DEBUG EXTRACTION ===');
            console.log('HTML Content:', gmsWrapper.innerHTML);
            console.log('Text Content:', gmsWrapper.textContent);
            console.log('Child elements:', gmsWrapper.children.length);
            console.log('All elements:', gmsWrapper.querySelectorAll('*').length);
            
            // List all child elements
            const children = Array.from(gmsWrapper.children);
            console.log('Child elements:', children.map(child => ({
                tagName: child.tagName,
                className: child.className,
                textContent: child.textContent.substring(0, 100)
            })));
            
            // Try parsing whatever is there
            try {
                const debugData = parseGMSData(gmsWrapper);
                console.log('Debug parsed data:', debugData);
                if (debugData.length > 0) {
                    sportsData = debugData;
                    displayData(debugData);
                    document.getElementById('exportCSV').disabled = false;
                    showStatus(`Debug extraction successful! Found ${debugData.length} items.`, 'success');
                } else {
                    showStatus('Debug extraction found no data - check console for details', 'error');
                }
            } catch (error) {
                console.error('Debug parsing failed:', error);
                showStatus('Debug parsing failed - check console for error details', 'error');
            }
        };
        
        document.querySelector('.controls').appendChild(debugButton);

        // Check if data is already loaded when page loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                const gmsWrapper = document.querySelector('.gms-wrapper');
                const hasData = gmsWrapper.textContent.trim().length > 50 && 
                               !gmsWrapper.textContent.includes('Loading sports data...');
                
                if (hasData) {
                    showStatus('Sports data appears to be loaded. Click "Load Sports Data" to extract it.', 'info');
                } else {
                    showStatus('Waiting for sports data to load...', 'info');
                }
                
                console.log('Page loaded. Current content length:', gmsWrapper.textContent.length);
                console.log('Has data:', hasData);
            }, 2000);
        });
    </script>
</body>
</html>
