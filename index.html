<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Match Data Filter</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      padding: 20px; 
      max-width: 1200px;
      margin: 0 auto;
      background-color: #f5f5f5;
    }
    
    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    textarea { 
      width: 100%; 
      height: 200px; 
      margin-bottom: 10px; 
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-family: monospace;
    }
    
    button { 
      padding: 12px 24px; 
      margin: 10px 10px 20px 0;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
    }
    
    .btn-primary {
      background-color: #007bff;
      color: white;
    }
    
    .btn-primary:hover {
      background-color: #0056b3;
    }
    
    .btn-success {
      background-color: #28a745;
      color: white;
    }
    
    .btn-success:hover {
      background-color: #1e7e34;
    }
    
    .btn-secondary {
      background-color: #6c757d;
      color: white;
    }
    
    .btn-secondary:hover {
      background-color: #545b62;
    }
    
    pre { 
      background: #f4f4f4; 
      padding: 15px; 
      border-radius: 8px;
      overflow: auto;
      max-height: 400px;
    }
    
    .data-preview {
      margin-top: 20px;
      border: 1px solid #ddd;
      border-radius: 5px;
      max-height: 400px;
      overflow: auto;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
    }
    
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    
    th {
      background-color: #f8f9fa;
      font-weight: bold;
      position: sticky;
      top: 0;
    }
    
    tr:hover {
      background-color: #f5f5f5;
    }
    
    #status {
      padding: 15px;
      border-radius: 5px;
      margin: 20px 0;
      font-weight: bold;
    }
    
    .status-info {
      background-color: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    
    .status-success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .status-error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Enhanced Match Data Filter</h1>
    <p>Paste match results below (supports various formats including dates, teams, scores, and venues):</p>
    <textarea id="rawData" placeholder="Example:
15 Oct 2024
Chelmsford 1 (M) 2:1 Waltham Forest 1 Chelmsford HC - Chelmer Park - Pitch 1
16 Oct 2024  
Team A 0:3 Team B School Sports Ground
Walkover - Team C vs Team D"></textarea>
    <br>
    <button onclick="parseData()" class="btn-primary">Parse Match Data</button>
    <button onclick="exportCSV()" class="btn-success" id="exportBtn" disabled>Export to CSV</button>
    <button onclick="clearData()" class="btn-secondary">Clear Data</button>
    
    <div id="status" class="hidden"></div>
    
    <h2>Parsed Matches:</h2>
    <div id="tableView" class="data-preview hidden">
      <table>
        <thead id="tableHeader"></thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
    
    <pre id="jsonOutput"></pre>
  </div>

  <script>
    let parsedMatches = [];

    // Status display function
    function showStatus(message, type = 'info') {
      const statusEl = document.getElementById('status');
      statusEl.textContent = message;
      statusEl.className = `status-${type}`;
      statusEl.classList.remove('hidden');
    }

    // Enhanced parsing function with sophisticated logic
    function parseData() {
      const raw = document.getElementById("rawData").value.trim();
      
      if (!raw) {
        showStatus('Please enter some match data to parse', 'error');
        return;
      }
      
      showStatus('Parsing match data...', 'info');
      
      try {
        const matches = parseMatchData(raw);
        parsedMatches = matches;
        
        if (matches.length > 0) {
          displayMatches(matches);
          showStatus(`Successfully parsed ${matches.length} matches`, 'success');
          document.getElementById('exportBtn').disabled = false;
        } else {
          showStatus('No matches found in the provided data', 'error');
        }
      } catch (error) {
        console.error('Parsing error:', error);
        showStatus(`Parsing error: ${error.message}`, 'error');
      }
    }

    function parseMatchData(rawText) {
      const matches = [];
      console.log('=== STARTING ENHANCED PARSE ===');
      
      // Split text into lines for processing
      const lines = rawText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
      console.log('Text lines found:', lines.length);
      
      // Process each line looking for fixture data
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        console.log(`Processing line ${i}: ${line}`);
        
        // Look for date pattern at start of line
        const datePattern = /(\d{1,2}\s+\w{3}\s+\d{4})/;
        const dateMatch = line.match(datePattern);
        
        if (dateMatch) {
          console.log('Found date:', dateMatch[1]);
          const match = { 
            Date: dateMatch[1],
            HomeTeam: '',
            AwayTeam: '',
            Score: '',
            Location: '',
            Outcome: '',
            Walkover: false
          };
          
          // Get text after the date
          let afterDate = line.substring(line.indexOf(dateMatch[1]) + dateMatch[1].length).trim();
          console.log('After date:', afterDate);
          
          // Check for walkover
          if (afterDate.toLowerCase().includes('walkover')) {
            match.Walkover = true;
            match.Outcome = 'Walkover';
            // Extract teams from walkover text
            const walkoverMatch = afterDate.match(/walkover.*?([^-]+)\s+vs?\s+([^-]+)/i);
            if (walkoverMatch) {
              match.HomeTeam = walkoverMatch[1].trim();
              match.AwayTeam = walkoverMatch[2].trim();
            } else {
              match.HomeTeam = afterDate.replace(/walkover/i, '').trim();
            }
          } else {
            // Look for score pattern
            const scoreMatches = afterDate.match(/(\d{1,2}\s*:\s*\d{1,2})/g);
            let scoreMatch = null;
            let scoreIndex = -1;
            
            if (scoreMatches) {
              // Find the score that looks most like an actual match score
              for (const potentialScore of scoreMatches) {
                const potentialIndex = afterDate.indexOf(potentialScore);
                const beforePotentialScore = afterDate.substring(0, potentialIndex).trim();
                
                // Check if what comes before looks like a complete team name
                if (beforePotentialScore.match(/.*\s\d(\s*\([MF]\))?\s*$/) || 
                    beforePotentialScore.match(/.*[a-zA-Z]\s*$/)) {
                  scoreMatch = { 1: potentialScore };
                  scoreIndex = potentialIndex;
                  break;
                }
              }
            }
            
            if (scoreMatch && scoreIndex >= 0) {
              console.log('Found valid score:', scoreMatch[1]);
              match.Score = scoreMatch[1];
              
              // Split by score using the exact position
              const beforeScore = afterDate.substring(0, scoreIndex).trim();
              const afterScore = afterDate.substring(scoreIndex + scoreMatch[1].length).trim();
              
              console.log('Before score (home team):', beforeScore);
              console.log('After score (away + location):', afterScore);
              
              match.HomeTeam = beforeScore;
              
              // Parse away team and location
              const result = parseAwayTeamAndLocation(afterScore);
              match.AwayTeam = result.awayTeam;
              match.Location = result.location;
              
              // Determine outcome
              match.Outcome = determineOutcome(match.Score, match.HomeTeam, match.AwayTeam);
            } else {
              // No score - might be a future fixture
              match.HomeTeam = afterDate;
              match.Outcome = 'Fixture (No Score)';
            }
          }
          
          console.log('Final match:', match);
          matches.push(match);
        }
      }
      
      // If no date-based parsing worked, try the original simple approach
      if (matches.length === 0) {
        console.log('No date-based matches found, trying simple parsing...');
        return parseDataSimple(rawText);
      }
      
      console.log('=== ENHANCED PARSE COMPLETE ===');
      console.log('Total matches found:', matches.length);
      return matches;
    }

    // Fallback to original simple parsing
    function parseDataSimple(raw) {
      const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
      const matches = [];
      let currentMatch = {};
      const datePattern = /^\d{1,2}\s+[A-Za-z]{3}\s+\d{4}$/;
      const scorePattern = /^\d+\s*:\s*\d+$/;
      
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (datePattern.test(line)) {
          // Save previous match if complete
          if (Object.keys(currentMatch).length > 0) {
            matches.push(formatMatch(currentMatch));
          }
          currentMatch = { Date: line, Walkover: false };
        } else if (scorePattern.test(line)) {
          currentMatch.Score = line;
        } else if (line.toLowerCase().includes("walkover")) {
          currentMatch.Walkover = true;
        } else if (!currentMatch.HomeTeam) {
          currentMatch.HomeTeam = line;
        } else if (!currentMatch.AwayTeam && !currentMatch.Score) {
          currentMatch.AwayTeam = line;
        } else if (!currentMatch.AwayTeam && currentMatch.Score) {
          currentMatch.AwayTeam = line;
        } else {
          currentMatch.Location = line;
        }
      }
      
      // Push last match if exists
      if (Object.keys(currentMatch).length > 0) {
        matches.push(formatMatch(currentMatch));
      }
      
      return matches;
    }

    function formatMatch(match) {
      const formatted = {
        Date: match.Date || '',
        HomeTeam: match.HomeTeam || '',
        AwayTeam: match.AwayTeam || '',
        Score: match.Score || '',
        Location: match.Location || '',
        Walkover: match.Walkover || false,
        Outcome: ''
      };
      
      if (match.Walkover) {
        formatted.Outcome = "Walkover";
      } else if (match.Score) {
        formatted.Outcome = determineOutcome(match.Score, match.HomeTeam, match.AwayTeam);
      } else {
        formatted.Outcome = 'Fixture (No Score)';
      }
      
      return formatted;
    }

    function determineOutcome(score, homeTeam, awayTeam) {
      if (!score) return '';
      
      const scoreParts = score.split(':').map(n => parseInt(n.trim()));
      if (scoreParts.length !== 2 || scoreParts.some(isNaN)) return '';
      
      const [homeScore, awayScore] = scoreParts;
      if (homeScore > awayScore) {
        return `${homeTeam} won (${homeScore}-${awayScore})`;
      } else if (homeScore < awayScore) {
        return `${awayTeam} won (${homeScore}-${awayScore})`;
      } else {
        return `Draw (${homeScore}-${awayScore})`;
      }
    }

    // Parse away team and location using enhanced logic
    function parseAwayTeamAndLocation(text) {
      console.log('Parsing away team/location from:', text);
      
      try {
        // Check for specific venue patterns first
        const chelmsfordHomePattern = /^(.+?)(Chelmsford\s*HC\s*[-\s]*Chelmer\s*Park\s*[-\s]*Pitch\s*\d)$/i;
        const chelmsfordMatch = text.match(chelmsfordHomePattern);
        
        if (chelmsfordMatch) {
          return {
            awayTeam: chelmsfordMatch[1].trim(),
            location: chelmsfordMatch[2].trim()
          };
        }
        
        // Look for other venue patterns
        const venuePatterns = [
          /^(.+?)(Waltham\s*Forest\s*Hockey\s*Club.*)$/i,
          /^(.+?)(Becket\s*Keys\s*School.*)$/i,
          /^(.+?)(\w+\s*HC\s*[-\s]*\w+.*)$/i
        ];
        
        for (const pattern of venuePatterns) {
          const match = text.match(pattern);
          if (match) {
            return {
              awayTeam: match[1].trim(),
              location: match[2].trim()
            };
          }
        }
        
        // Look for teams ending with digits followed by location
        const teamNumberPattern = /^(.*?\b\w+\s+\d)(.+)$/;
        const teamMatch = text.match(teamNumberPattern);
        
        if (teamMatch) {
          const potentialTeam = teamMatch[1].trim();
          const potentialLocation = teamMatch[2].trim();
          
          // Check if location part looks like a venue
          if (potentialLocation.length > 5 && 
              (potentialLocation.includes('HC') || 
               potentialLocation.includes('School') || 
               potentialLocation.includes('Club') ||
               potentialLocation.includes('Park') ||
               potentialLocation.includes('Pitch'))) {
            return {
              awayTeam: potentialTeam,
              location: potentialLocation
            };
          }
        }
        
        // Fallback: split by common location words
        const locationWords = ['Hockey', 'School', 'Club', 'Park', 'Pitch', 'Centre', 'Ground', 'HC'];
        
        for (const word of locationWords) {
          const wordIndex = text.indexOf(word);
          if (wordIndex > 3) {
            let wordStart = wordIndex;
            while (wordStart > 0 && text[wordStart - 1] !== ' ') {
              wordStart--;
            }
            
            const potentialTeam = text.substring(0, wordStart).trim();
            const potentialLocation = text.substring(wordStart).trim();
            
            if (potentialTeam.length > 2 && potentialLocation.length > 2) {
              return {
                awayTeam: potentialTeam,
                location: potentialLocation
              };
            }
          }
        }
        
        // Last resort: everything is away team
        return {
          awayTeam: text,
          location: ''
        };
        
      } catch (error) {
        console.error('Error parsing away team/location:', error);
        return {
          awayTeam: text,
          location: ''
        };
      }
    }

    function displayMatches(matches) {
      // Display as table
      const tableView = document.getElementById('tableView');
      const header = document.getElementById('tableHeader');
      const body = document.getElementById('tableBody');
      
      // Clear existing content
      header.innerHTML = '';
      body.innerHTML = '';
      
      if (matches.length > 0) {
        // Create header
        const headerRow = document.createElement('tr');
        const keys = ['Date', 'HomeTeam', 'Score', 'AwayTeam', 'Location', 'Outcome'];
        keys.forEach(key => {
          const th = document.createElement('th');
          th.textContent = key.replace(/([A-Z])/g, ' $1').trim();
          headerRow.appendChild(th);
        });
        header.appendChild(headerRow);
        
        // Create data rows
        matches.forEach(match => {
          const tr = document.createElement('tr');
          keys.forEach(key => {
            const td = document.createElement('td');
            td.textContent = match[key] || '';
            tr.appendChild(td);
          });
          body.appendChild(tr);
        });
        
        tableView.classList.remove('hidden');
      }
      
      // Also display as JSON
      document.getElementById("jsonOutput").textContent = JSON.stringify(matches, null, 2);
    }

    function exportCSV() {
      if (parsedMatches.length === 0) {
        showStatus('No data to export', 'error');
        return;
      }
      
      const keys = ['Date', 'HomeTeam', 'Score', 'AwayTeam', 'Location', 'Outcome'];
      
      // Create CSV header
      let csv = keys.map(key => `"${key}"`).join(',') + '\n';
      
      // Add data rows
      parsedMatches.forEach(match => {
        const values = keys.map(key => {
          const value = match[key] || '';
          return `"${String(value).replace(/"/g, '""')}"`;
        });
        csv += values.join(',') + '\n';
      });
      
      // Download CSV
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `match_data_${new Date().toISOString().slice(0, 10)}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      showStatus('CSV exported successfully', 'success');
    }

    function clearData() {
      document.getElementById('rawData').value = '';
      document.getElementById('jsonOutput').textContent = '';
      document.getElementById('tableView').classList.add('hidden');
      document.getElementById('status').classList.add('hidden');
      document.getElementById('exportBtn').disabled = true;
      parsedMatches = [];
    }
  </script>
</body>
</html>
